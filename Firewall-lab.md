

# 21110025 - Nguyễn Thành Hiếu
# Extra Lab: firewall

## Setup docker for lab

*First we will launch the target.py website. We can see the website's interface:*

<img width="726" alt="fw1.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/fw1.jpg" >
<img width="726" alt="fw2.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/fw2.jpg" >

*check running containers*

<img width="726" alt="fw3.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/fw3.jpg" >

*You will see a list of running containers, including "router" , "inner" , "outsider" , "iweb" and "badsite".*
*Set up iptables rules on the container router
a. Block all access to the router except ping*

*Check from a subnet to the router
To check the connection from a subnet to the router, you need to know the IP address of the router container. For example, let's say the router's IP address is 172.16.10.100:*
*Block access to the router except for ping:*
<img width="726" alt="fw4.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/fw4.jpg" >

<img width="726" alt="fw5.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/fw5.jpg" >


## 1.2: Doing the transaction

*transfer money to Bob's account, we will go to the transaction page via the link '/transfer'*

<img width="726" alt="lab3_1.1-6.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/lab3_1.1-6.jpg" >


<img width="726" alt="lab3_1.1-7.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/lab3_1.1-7.jpg" >


*return to check the balance again, then the balance will be deducted by the exact amount we just transferred:*

<img width="726" alt="lab3_1.1-8.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/lab3_1.1-8.jpg" >

## 1.3: Tranfer money illegitimately

*To perform a CSRF attack when user Alice accidentally downloads a file hidden_form.html. We will launch the above website. As soon as the website is launched, user Alice will immediately lose 1000 and the attacker account will gain 1000:*

<img width="726" alt="lab3_1.3-1.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/lab3_1.3-1.jpg" >

<img width="726" alt="lab3_1.3-2.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/lab3_1.3-2.jpg" >


*Login into attacker account and check:*

<img width="726" alt="lab3_1.3-3.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/lab3_1.3-3.jpg" >

<img width="726" alt="lab3_1.3-4.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/lab3_1.3-4.jpg" >

*When launching the malicious html file, the input form to perform transactions of the official website was called to the fake website and at the same time it made transactions to an unwanted account, the account by Attacker. At that time, the attack through the CSRF vulnerability was performed.*

# Task 2: CSRF Countermeasure implementation
## 2.1: Solution 1:
**Uses CSRF Token** *- initialize a random value generated by the server and sent to the client.When the client sends a POST request, this token will be sent with the request and the server will check the token to confirm the request is valid.*

*install the Flask-WTF*

<img width="726" alt="lab3_2-1.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/lab3_2-1.jpg" >

*Configure CSRF token in website in file target.py*

<img width="726" alt="lab3_2-2.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/lab3_2-2.jpg" >

*After the configuration is complete, run the website again and open the malicious website used to attack the above vulnerability. You will see that the attack has failed and has been blocked:*

<img width="726" alt="lab3_2-3.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/lab3_2-3.jpg" >

<img width="726" alt="lab3_2-4.jpg" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/lab3_2-4.jpg" >

## 2.2: Solution 2:
**SameSite** *is an attribute in HTTP cookies used to specify how the cookie should be sent with cross-origin requests.*

*Use the SameSite Cookie Attribute to specify whether your cookie should be sent with cross-domain requests. Setting the SameSite attribute to "Strict" or "Lax" can help prevent CSRF attacks.*

_Setting samesite cookie is strict_

<img width="726" alt="code1" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/code1.jpg" >

**Set SameSite to Strict:** *"resp.set_cookie('user_session', json.dumps({'username': username}), samesite='Strict') "*

*Here, we've added samesite='Strict' when setting the cookie after the user logs in to ensure that the cookie is only sent in the first-party context.*

<img width="726" alt="code2" src="https://github.com/NguyenThanhHieu-21110025/InformationSecurity-Lab/blob/main/images/code2.jpg" >

**Set SameSite to Strict:** *"resp.set_cookie('user_session', '', expires=0, samesite='Strict') "*

*Here, when the user logs out and the cookie is deleted, we have also added samesite='Strict' to ensure that the cookie is deleted only within the same site context.*

_This way, we've updated our Flask application to use SameSite with the "Strict" setting to effectively protect against CSRF attacks._
